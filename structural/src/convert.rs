use std_::fmt::{self, Display};

#[cfg(feature = "std")]
use std::error::Error as StdError;

/// For conversions between structural types.
///
/// Since Rust 1.41 it's possible to implement `FromStructural<LocalType>` for an external type,
/// where `LocalType` is a non-structural type defined locally.
///
/// Usually types implement `FromStructural` only bounding the
/// trait type parameter with the structural alias generated by the `Structural` macro,
/// which means that `FromStructural` covers at least the types that are structurally
/// equivalent.
///
/// # Struct Example
///
/// This example demonstrates how this trait can be manually implemented for structs.
///
/// ```rust
/// use structural::{convert::FromStructural, StructuralExt, Structural, fp, make_struct};
///
/// {
///     let this = Point{x: 33, y:45};
///     assert_eq!(this.into_struc::<Entity>(), Entity{x: 33, y: 45, health: 100});
/// }
/// {
///     let this = make_struct!{x: 100, y: 200, foo: "hello"};
///     assert_eq!(this.into_struc::<Entity>(), Entity{x: 100, y: 200, health: 100});
/// }
/// {
///     // The `Point_SI` trait was generated by the Structural derive on `Point`,
///     // aliasing it's accessor trait impls.
///     let this: Box<dyn Point_SI<u32>> = Box::new(Point{x: 2016, y: 2080});
///     assert_eq!(this.into_struc::<Entity>(), Entity{x: 2016, y: 2080, health: 100});
/// }
///
/// #[derive(Structural)]
/// struct Point<T>{
///     pub x: T,
///     pub y: u32,
/// }
///
/// #[derive(Debug,PartialEq,Structural)]
/// struct Entity{
///     #[struc(public)]
///     x: u32,
///
///     #[struc(public)]
///     y: u32,
///
///     health: u32,
/// }
///
/// // This macro implements TryFromStructural for Entity by
/// // delegating to the passed-in implementation of `FromStructural`.
/// //
/// // `TryFromStructural` cannot have a blanket impl because it would collide
/// // with user implementations.
/// structural::z_impl_from_structural!{
///     impl[F] FromStructural<F> for Entity
///     where[ F: Entity_SI ]
///     {
///         fn from_structural(from){
///             let (x, y) = from.into_fields(fp!(x, y));
///             Entity{ x, y, health: 100 }
///         }    
///     }
/// }
///
/// ```
///
/// # Enum Example
///
/// This example demonstrates how this trait can be manually implemented for an enum with one
/// private field (as in a field that doesn't have accessor impls to get it).
///
/// ```rust
/// use structural::{
///     convert::FromStructural,
///     for_examples::OptionLike,
///     structural_aliases::OptionMove_ESI,
///     StructuralExt, Structural, switch,
/// };
///
/// assert_eq!(Some(100).into_struc::<UberOption<_>>(), UberOption::Some(100, 100));
/// assert_eq!(None.into_struc::<UberOption<u32>>(), UberOption::None);
///
/// assert_eq!(OptionLike::Some(3).into_struc::<UberOption<_>>(), UberOption::Some(3, 3));
/// assert_eq!(OptionLike::None.into_struc::<UberOption<u32>>(), UberOption::None);
///
/// // Converting an UberOption back to itself with `FromStructural` drops the
/// // `#[struct(not_public)]` field,because it has no accessor impls.
/// assert_eq!(
///     UberOption::Some(5, 200).into_struc::<UberOption<_>>(),
///     UberOption::Some(5, 5)
/// );
/// assert_eq!(
///     UberOption::None.into_struc::<UberOption<u32>>(),
///     UberOption::None,
/// );
///
/// #[derive(Debug,Structural,PartialEq)]
/// enum UberOption<T>{
///     Some(
///         T,
///         #[struc(not_public)]
///         T,
///     ),
///     None,
/// }
///
/// // This macro implements TryFromStructural for Entity by
/// // delegating to the passed-in implementation of `FromStructural`.
/// //
/// // `TryFromStructural` cannot have a blanket impl because it would collide
/// // with user implementations.
/// structural::z_impl_from_structural!{
///     impl[F, T] FromStructural<F> for UberOption<T>
///     where[
///         F: OptionMove_ESI<T>,
///         T: Clone,
///     ]{
///         fn from_structural(from){
///             switch!{from;
///                 Some(x) => Self::Some(x.clone(), x),
///                 None => Self::None,
///             }
///         }
///     }
/// }
///
/// ```
///
pub trait FromStructural<T>: TryFromStructural<T> {
    /// Performs the conversion
    fn from_structural(from: T) -> Self;
}

/// For conversions between structural types.
///
/// This trait has a blanket implementations for all types that implement FromStructural.
///
/// # Example
///
/// This example demonstrates how you can use `IntoStructural` as a bound.
///
/// ```rust
/// use structural::convert::IntoStructural;
///
/// assert_eq!( into_other((0, 1, 2), [3, 4]), [[0, 1], [3, 4]] );
///
/// fn into_other<T, U>(left: T, right: U)-> [U;2]
/// where
///     T: IntoStructural<U>,
/// {
///     [left.into_structural(), right]
/// }
///
/// ```
///
pub trait IntoStructural<T>: Sized {
    /// Performs the conversion
    fn into_structural(self) -> T;
}

impl<This, T> IntoStructural<T> for This
where
    T: FromStructural<This>,
{
    fn into_structural(self) -> T {
        T::from_structural(self)
    }
}

///////////////////////////////////////////////////////////////////////////////

pub trait TryFromStructural<T>: Sized {
    type Error;

    /// Performs the conversion
    fn try_from_structural(from: T) -> Result<Self, TryFromError<T, Self::Error>>;
}

pub trait TryIntoStructural<T>: Sized {
    type Error;

    /// Performs the conversion
    fn try_into_structural(self) -> Result<T, TryFromError<Self, Self::Error>>;
}

impl<This, T> TryIntoStructural<T> for This
where
    T: TryFromStructural<This>,
{
    type Error = T::Error;

    fn try_into_structural(self) -> Result<T, TryFromError<Self, Self::Error>> {
        T::try_from_structural(self)
    }
}

///////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Clone, PartialEq)]
pub struct TryFromError<T, E> {
    pub from: T,
    pub error: E,
}

impl<T, E> TryFromError<T, E> {
    pub fn new(from: T, error: E) -> Self {
        Self { from, error }
    }
}

impl<T> TryFromError<T, EmptyTryFromError> {
    pub fn with_empty_error(from: T) -> Self {
        Self {
            from,
            error: EmptyTryFromError,
        }
    }
}

impl<T, E> Display for TryFromError<T, E>
where
    E: Display,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        Display::fmt(&self.error, f)
    }
}

#[cfg(feature = "std")]
#[allow(deprecated)]
impl<T, E> StdError for TryFromError<T, E>
where
    T: fmt::Debug,
    E: StdError,
{
    fn source(&self) -> Option<&(dyn StdError + 'static)> {
        self.error.source()
    }
    fn description(&self) -> &str {
        self.error.description()
    }
    fn cause(&self) -> Option<&dyn StdError> {
        self.error.cause()
    }
}

///////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Clone, PartialEq)]
pub struct EmptyTryFromError;

impl Display for EmptyTryFromError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        Display::fmt("failed TryIntoStructural conversion", f)
    }
}

#[cfg(feature = "std")]
impl StdError for EmptyTryFromError {}
